from ompl import util as ou
from ompl import base as ob
from ompl import geometric as og
from math import sqrt
from sys import argv
import argparse
import myFuncMulti as mfm
import ompl_demo as odm
import matplotlib.pyplot as plt
from scipy.ndimage.filters import gaussian_filter as scipy_gaussian
import numpy as np
import math
from scipy.ndimage.filters import gaussian_filter as scipy_gaussian
import scipy.ndimage
from scipy.interpolate import interp1d

pathFound, path = odm.plan(mfm.runTime, mfm.plannerType, mfm.objectiveType, mfm.fname, mfm.bound, mfm.start_pt, mfm.goal_pt)

if pathFound:
	pathList = mfm.getPathPointAsList(path)
	pathList = np.array(pathList) 		# pathList is numpy array now
else:
	print "Path not found..."

fig, ax= plt.subplots()
ax.axis('equal')

long_path = np.array([[0,0]])
print long_path.shape
f = interp1d(pathList[:,0], pathList[:,1], kind='cubic')
x = np.linspace(0, 10, num=500, endpoint=True)
y = f(x)
for i in range(x.shape[0]):
	long_path = np.append(long_path, [[x[i], y[i]]], axis=0)
long_path = np.delete(long_path, 0, axis=0)

leftBot_angle = math.pi/4
rightBot_angle = -math.pi/4
bot3_angle = 3*math.pi/4
bot4_angle = -3*math.pi/4

left_dist = mfm.left_bot_dist_generator(long_path, leftBot_angle)
right_dist = mfm.right_bot_dist_generator(long_path, rightBot_angle)
bot3_dist = mfm.left_bot_dist_generator(long_path, bot3_angle)
bot4_dist = mfm.right_bot_dist_generator(long_path, bot4_angle)

leftDist = np.minimum(left_dist, bot3_dist)
rightDist = np.minimum(right_dist, bot4_dist)

leftBot_path = mfm.bot_path_generator(long_path, leftDist, leftBot_angle)
rightBot_path = mfm.bot_path_generator(long_path, rightDist, rightBot_angle)
bot3_path = mfm.bot_path_generator(long_path, leftDist, bot3_angle)
bot4_path = mfm.bot_path_generator(long_path, rightDist, bot4_angle)

pathX, pathY = long_path.T
for i in range(len(leftBot_path)):
	plt.cla()
	for obstacles in mfm.circularObstacles:
		ax.add_patch(plt.Circle((obstacles[0], obstacles[1]), obstacles[2], color='r'))
	ax.plot(pathX, pathY, 'b')
	vertices = np.array([[0, 0]])
	vertices = np.append(vertices, [[leftBot_path[i][0], leftBot_path[i][1]]], axis = 0)
	vertices = np.append(vertices, [[bot3_path[i][0], bot3_path[i][1]]], axis = 0)
	vertices = np.append(vertices, [[bot4_path[i][0], bot4_path[i][1]]], axis = 0)
	vertices = np.append(vertices, [[rightBot_path[i][0], rightBot_path[i][1]]], axis = 0)
	vertices = np.delete(vertices, [0], axis = 0)
	ax.add_patch(plt.Polygon(vertices, closed = True, fill = False))

	ax.add_patch(plt.Circle((leftBot_path[i][0], leftBot_path[i][1]), mfm.bot_rad, color='b'))
	ax.add_patch(plt.Circle((rightBot_path[i][0], rightBot_path[i][1]), mfm.bot_rad, color='g'))
	ax.add_patch(plt.Circle((bot3_path[i][0], bot3_path[i][1]), mfm.bot_rad, color='b'))
	ax.add_patch(plt.Circle((bot4_path[i][0], bot4_path[i][1]), mfm.bot_rad, color='g'))

	ax.plot()
	plt.pause(0.01)
	


bot1x, bot1y = leftBot_path.T
ax.plot(bot1x, bot1y, 'go-')
bot2x, bot2y = rightBot_path.T
ax.plot(bot2x, bot2y, 'ro-')

plt.show()
exit()




































leftBot_forward_path = np.array([[0,0]])
rightBot_forward_path = np.array([[0,0]])
for i in range(1, long_path.shape[0]):
	if left_dist[i] < mfm.bot_rad and right_dist[i] < mfm.bot_rad:
		print "No proper path generated by OMPL..."
		print "Check long path point", i
		exit()
	if left_dist[i] < mfm.bot_rad:
		right_dist[i] = right_dist[i] + mfm.bot_rad - left_dist[i]
	if right_dist[i] < mfm.bot_rad:
		left_dist[i] = left_dist[i] + mfm.bot_rad - right_dist[i]
	
	current_theta = math.atan2(float(long_path[i][1] - long_path[i-1][1]), float(long_path[i][0] - long_path[i-1][0]))
	
	leftBot_theta = current_theta + leftBot_angle
	next_pt =np.array([[long_path[i][0] + (left_dist[i]) * np.cos(leftBot_theta), long_path[i][1] + (left_dist[i]) * np.sin(leftBot_theta)]])
	leftBot_forward_path = np.append(leftBot_forward_path, next_pt, axis = 0)

	rightBot_theta = current_theta + (rightBot_angle)
	next_pt =np.array([[long_path[i][0] + (right_dist[i]) * np.cos(rightBot_theta), long_path[i][1] + (right_dist[i]) * np.sin(rightBot_theta)]])
	rightBot_forward_path = np.append(rightBot_forward_path, next_pt, axis = 0)

print leftBot_forward_path.shape, rightBot_forward_path.shape

pathX, pathY = long_path.T
for i in range(len(leftBot_forward_path)):
	plt.cla()
	for obstacles in mfm.circularObstacles:
		ax.add_patch(plt.Circle((obstacles[0], obstacles[1]), obstacles[2], color='r'))
	ax.plot(pathX, pathY, 'b')
	ax.add_patch(plt.Circle((leftBot_forward_path[i][0], leftBot_forward_path[i][1]), mfm.bot_rad, color='b'))
	ax.add_patch(plt.Circle((rightBot_forward_path[i][0], rightBot_forward_path[i][1]), mfm.bot_rad, color='g'))
	ax.plot()
	plt.pause(0.001)
	


bot1x, bot1y = leftBot_forward_path.T
ax.plot(bot1x, bot1y, 'go-')
bot2x, bot2y = rightBot_forward_path.T
ax.plot(bot2x, bot2y, 'ro-')


#bot1x, bot1y = bot1_path_smooth.T
#ax.plot(bot1x, bot1y, 'go-')
#
#bot2x, bot2y = bot2_path_smooth.T
#ax.plot(bot2x, bot2y, 'ro-')
#
#
#pathX, pathY = long_path.T
#ax.plot(pathX, pathY, 'bo')
#bot1x, bot1y = bot1_path.T
#ax.plot(bot1x, bot1y, 'r-')
#
##bot1x, bot1y = bot1_path_smooth_fwd.T
##ax.plot(bot1x, bot1y, 'bo')
##plt.cla()
#ax1.plot(bot2_dist_initial, 'ro')
#ax1.plot(bot2_dist, 'go')
plt.show()
exit()























